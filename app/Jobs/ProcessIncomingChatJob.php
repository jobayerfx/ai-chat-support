<?php

namespace App\Jobs;

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;
use App\Models\Tenant;
use App\Models\AIConversation;
use App\Models\AIUsageLog;
use App\Services\AIEligibilityService;
use App\Services\PromptBuilderService;
use App\Services\AIResponseService;
use App\Services\ChatwootService;

class ProcessIncomingChatJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public $tries = 3;
    public $backoff = [10, 30, 60]; // Retry delays in seconds

    private int $tenantId;
    private int $conversationId;
    private string $message;

    /**
     * Create a new job instance.
     */
    public function __construct(int $tenantId, int $conversationId, string $message)
    {
        $this->tenantId = $tenantId;
        $this->conversationId = $conversationId;
        $this->message = $message;
    }

    /**
     * Execute the job.
     */
    public function handle(): void
    {
        try {
            // Resolve tenant (idempotent check)
            $tenant = Tenant::find($this->tenantId);
            if (!$tenant) {
                Log::error('Tenant not found in job', ['tenant_id' => $this->tenantId]);
                return;
            }

            // Get or create conversation (idempotent)
            $conversation = AIConversation::firstOrCreate(
                [
                    'tenant_id' => $this->tenantId,
                    'conversation_id' => $this->conversationId,
                ],
                [
                    'messages' => [],
                    'ai_active' => true,
                ]
            );

            // Check AI eligibility
            $eligibilityService = app(AIEligibilityService::class);
            $eligibility = $eligibilityService->checkEligibility($tenant, $conversation, $this->message);

            if (!$eligibility['eligible']) {
                Log::info('AI processing not eligible', [
                    'tenant_id' => $this->tenantId,
                    'conversation_id' => $this->conversationId,
                    'reason' => $eligibility['reason']
                ]);
                return;
            }

            // Retrieve relevant knowledge
            $knowledge = $this->getRelevantKnowledge($tenant, $this->message);

            // Build AI prompt
            $promptBuilder = app(PromptBuilderService::class);
            $prompt = $promptBuilder->buildPrompt($knowledge, 'en'); // TODO: Detect language

            // Generate AI response
            $responseService = app(AIResponseService::class);
            $aiResponse = $responseService->generateResponse($prompt);

            // Process response based on confidence and sensitivity
            $this->processAIResponse($aiResponse, $conversation);

            // Log usage (idempotent - use upsert or check existing)
            $this->logUsage($tenant, $conversation, $aiResponse);

        } catch (\Exception $e) {
            Log::error('Error processing incoming chat', [
                'tenant_id' => $this->tenantId,
                'conversation_id' => $this->conversationId,
                'error' => $e->getMessage(),
                'attempt' => $this->attempts()
            ]);

            throw $e; // Re-throw for retry
        }
    }

    /**
     * Get relevant knowledge documents for the message
     */
    private function getRelevantKnowledge(Tenant $tenant, string $message): array
    {
        // TODO: Implement semantic search using embeddings
        // For now, return all tenant knowledge documents
        return $tenant->knowledgeDocuments->pluck('content')->toArray();
    }

    /**
     * Process AI response based on confidence and sensitivity
     */
    private function processAIResponse(array $aiResponse, AIConversation $conversation): void
    {
        $chatwootService = app(ChatwootService::class);

        if ($aiResponse['confidence'] >= 0.7 && !$aiResponse['sensitive']) {
            // High confidence, safe response - send to Chatwoot
            $chatwootService->sendMessage($this->conversationId, $aiResponse['response']);

            Log::info('AI response sent to Chatwoot', [
                'conversation_id' => $this->conversationId,
                'confidence' => $aiResponse['confidence']
            ]);

        } elseif ($aiResponse['confidence'] >= 0.4 && !$aiResponse['sensitive']) {
            // Medium confidence - send with disclaimer
            $responseWithDisclaimer = $aiResponse['response'] . "\n\n*This response is generated by AI. If you need human assistance, please let us know.*";
            $chatwootService->sendMessage($this->conversationId, $responseWithDisclaimer);

            Log::info('AI response sent with disclaimer', [
                'conversation_id' => $this->conversationId,
                'confidence' => $aiResponse['confidence']
            ]);

        } else {
            // Low confidence or sensitive - escalate to human
            $chatwootService->sendMessage($this->conversationId, "I'm transferring you to a human agent for better assistance.");
            $chatwootService->assignToAgent($this->conversationId, 1); // TODO: Get actual agent ID
            $chatwootService->disableAI($this->conversationId);

            Log::info('Escalated to human agent', [
                'conversation_id' => $this->conversationId,
                'confidence' => $aiResponse['confidence'],
                'sensitive' => $aiResponse['sensitive']
            ]);
        }
    }

    /**
     * Log AI usage for billing/analytics
     */
    private function logUsage(Tenant $tenant, AIConversation $conversation, array $aiResponse): void
    {
        // TODO: Calculate actual token usage from LLM response
        $estimatedTokens = strlen($this->message) + strlen($aiResponse['response']);

        AIUsageLog::create([
            'tenant_id' => $tenant->id,
            'conversation_id' => $this->conversationId,
            'tokens_used' => $estimatedTokens,
            'cost' => $this->calculateCost($estimatedTokens),
        ]);
    }

    /**
     * Calculate cost based on token usage
     */
    private function calculateCost(int $tokens): float
    {
        // TODO: Use actual pricing from LLM provider
        return $tokens * 0.0001; // Example rate
    }

    /**
     * Handle job failure
     */
    public function failed(\Throwable $exception): void
    {
        Log::error('ProcessIncomingChatJob failed permanently', [
            'tenant_id' => $this->tenantId,
            'conversation_id' => $this->conversationId,
            'error' => $exception->getMessage()
        ]);

        // TODO: Send alert or notification
    }
}
